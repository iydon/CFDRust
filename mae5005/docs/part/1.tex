\section{第一次作业}

\begin{homework}[label={H:1-1}]
    Using the department Unix computer and a simple Fortran code, investigate how an input real number is outputted (i.e., interpreted by a computer in bits and bytes) under the single precision representation.

    \begin{enumerate}[label=(\alph*)]
        \item Input = 0.61E-45
        \item Input = 0.82E-45
        \item Input = 2.13E-45
        \item Input = 2.34E-45
        \item Input = 3.65E-10
        \item Input = 4.06E+30
        \item Input = 3.40E+38
        \item Input = 3.41E+38
    \end{enumerate}

    Namely, in each case, (i) report the actual output of your input; (ii) explain the precise binary form used by the computer. Your code is expected to be less than 10 lines.
\end{homework}

\begin{fortran}[label={C:1-1}]{\href{https://github.com/iydon/CFDRust/blob/main/mae5005/code/1/input_and_output.f90}{input\_and\_output.f90}}
program main
   use, intrinsic :: iso_fortran_env, only: f64=>real32
   implicit none

   real(f64) :: number

   write(*, fmt='(A)', advance='no') 'Input  = '
   read(*, *) number
   write(*, fmt='(A, ES14.8, A, b32.32)') 'Output = ', number, ' = ', transfer(number, 0)
end program main
\end{fortran}

根据 Homework~\ref{H:1-1}，可以编写如 Code~\ref{C:1-1} 所示的代码，其与示例代码主要有以下两点不同：

\begin{itemize}
    \item 去除无限循环，一方面是为了避免使用键盘中断的方式退出程序，保证正确的程序返回码，另一方面是为了构建输入-输出模式的单元测试，方便在不同平台上快速验证；
    \item 采用 \href{https://fortran-lang.org/learn/quickstart/variables}{fortran-lang.org} 推荐的浮点数与字面常量声明格式，但是，为了降低后续移植到 \href{https://www.rust-lang.org}{Rust} 语言的心智负担，将推荐使用的 \verb|sp|、\verb|dp| 与 \verb|qp| 类型别名更改为 \verb|f32|、\verb|f64| 与 \verb|f128|。
\end{itemize}

为了保证在各平台上运行结果一致，同时降低测试的复杂度，可将 Homework~\ref{H:1-1} 中的测试例提取出来作为输入，主力平台上的代码运行结果作为标准输出\footnote{此处假设自己编写的代码在主力平台上的运行结果正确。}，与其余平台上的代码运行结果进行比较，从而判断代码运行结果的一致性。因此，按照以上思路，可以编写较为简陋的\href{https://github.com/iydon/CFDRust/blob/main/mae5005/test.py}{单元测试}，其缺点为输入与标准输出需要按照一定的模式写入代码中，且目前只支持通过完全匹配来判断输出结果是否正确。

利用以上编写的单元测试在不同平台进行验证，可以发现如下版本的 \texttt{GFortran} 在给定输入下输出结果一致，如表~\ref{T:1-1-input_and_output} 所示。

\begin{itemize}
    \item \verb|GNU Fortran (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0|
    \item \verb|GNU Fortran (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0|
    \item \verb|GNU Fortran (GCC) 11.2.1 20220127 (Red Hat 11.2.1-9)|
\end{itemize}

而在如下版本的 \texttt{GFortran} 中，部分算例的输出结果与标准输出结果不一致，有差异的算例及输出结果如表~\ref{T:1-1-input_and_output_diff} 所示。初步猜测为不同版本的 \texttt{GFortran} 在字面常量解析的过程中存在细微差异，无法判断此差异与其他因素是否有关，因此，之后的代码作业也会使用单元测试，以保证各平台上运行结果的一致性。

\begin{itemize}
    \item \verb|GNU Fortran (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44)|
\end{itemize}

\begin{table}[H]
    \caption{\texttt{input\_and\_output.f90} 的输入与输出}\label{T:1-1-input_and_output}
    \centering
    \begin{tabular}{lll}
        \toprule
        测试例 & 标准输入流 & 标准输出流 \\ \midrule
        \rowcolor[HTML]{EFEFEF}
        1 & \verb|0.61E-45| & \verb|Output = 0.00000000E+00 = 00000000000000000000000000000000| \\
        2 & \verb|0.82E-45| & \verb|Output = 1.40129846E-45 = 00000000000000000000000000000001| \\
        \rowcolor[HTML]{EFEFEF}
        3 & \verb|2.13E-45| & \verb|Output = 2.80259693E-45 = 00000000000000000000000000000010| \\
        4 & \verb|2.34E-45| & \verb|Output = 2.80259693E-45 = 00000000000000000000000000000010| \\
        \rowcolor[HTML]{EFEFEF}
        5 & \verb|3.65E-10| & \verb|Output = 3.65000002E-10 = 00101111110010001010100100101111| \\
        6 & \verb|4.06E+30| & \verb|Output = 4.05999996E+30 = 01110010010011001111101001000101| \\
        \rowcolor[HTML]{EFEFEF}
        7 & \verb|3.40E+38| & \verb|Output = 3.39999995E+38 = 01111111011111111100100110011110| \\
        8 & \verb|3.41E+38| & \verb|Output =       Infinity = 01111111100000000000000000000000| \\ \bottomrule
    \end{tabular}
\end{table}

\begin{table}[H]
    \caption{\texttt{input\_and\_output.f90} 的输入与输出（差异）}\label{T:1-1-input_and_output_diff}
    \centering
    \begin{tabular}{lll}
        \toprule
        测试例 & 标准输入流 & 标准输出流 \\ \midrule
        \rowcolor[HTML]{EFEFEF}
        2 & \verb|0.82E-45| & \verb|Output = 0.00000000E+00 = 00000000000000000000000000000000| \\ \bottomrule
    \end{tabular}
\end{table}

根据 \texttt{binary32} 格式与浮点数算术标准\cite{wiki:single-precision_floating-point}，可以编写如附录~\ref{S:appendix-code} 中 Code~\ref{C:python-bits} 所示的辅助程序，将 \texttt{binary32} 格式中的符号位、指数位与小数位分别提取出来，并计算出对应的浮点数，最后的计算公式如表~\ref{T:1-1-bits} 所示，而具体浮点数的大小如表~\ref{T:1-1-input_and_output} 所示。

\begin{table}[H]
    \caption{\texttt{binary32} 格式与浮点数的转换}\label{T:1-1-bits}
    \centering
    \begin{tabular}{ll}
        \toprule
        \texttt{binary32} 格式 & 公式 \\ \midrule
        \rowcolor[HTML]{EFEFEF}
        \verb|0 00000000 00000000000000000000000| & $(-1)^0 \times 2^{-126} \times (0.00000000000000000000000)_2$ \\
        \verb|0 00000000 00000000000000000000001| & $(-1)^0 \times 2^{-126} \times (0.00000000000000000000001)_2$ \\
        \rowcolor[HTML]{EFEFEF}
        \verb|0 00000000 00000000000000000000010| & $(-1)^0 \times 2^{-126} \times (0.00000000000000000000010)_2$ \\
        \verb|0 00000000 00000000000000000000010| & $(-1)^0 \times 2^{-126} \times (0.00000000000000000000010)_2$ \\
        \rowcolor[HTML]{EFEFEF}
        \verb|0 01011111 10010001010100100101111| & $(-1)^0 \times 2^{(01011111)_2-127} \times (1.10010001010100100101111)_2$ \\
        \verb|0 11100100 10011001111101001000101| & $(-1)^0 \times 2^{(11100100)_2-127} \times (1.10011001111101001000101)_2$ \\
        \rowcolor[HTML]{EFEFEF}
        \verb|0 11111110 11111111100100110011110| & $(-1)^0 \times 2^{(11111110)_2-127} \times (1.11111111100100110011110)_2$ \\
        \verb|0 11111111 00000000000000000000000| & $\infty$ \\ \bottomrule
    \end{tabular}
\end{table}



\begin{homework}[label={H:1-2}]
    In 1995 (very recent in terms of the history of mathematics), Simon Plouffe discovered an amazing formulae for computing $\pi$, which, in principle, allows one to compute $\pi$ to any binary (decimal) digit. His formulae is

    \[
        \pi = \sum_{k=0}^{\infty} \left[
            \frac{1}{16^k} \left(
                \frac{4}{8k+1} - \frac{2}{8k+4} - \frac{1}{8k+5} - \frac{1}{8k+6}
            \right)
        \right]
    \]

    Clearly, the different terms in terms of $k$, decreases quickly as $k$ is increased. Here, we shall use the above formulae to compute $\pi$, at different accuracies and investigate how many terms are needed for each case.

    \begin{enumerate}[label=(\alph*)]
        \item Write a single precision Fortran code, to compute $\pi$ using the above formulae;
        \item Write a double precision Fortran code, to compute $\pi$ using the above formulae;
        \item Write a quadruple precision Fortran code, to compute $\pi$ using the above formulae.
    \end{enumerate}

    Report, in each case, what do you obtain? what is the accuracy? How many terms, in terms of $k$, are needed to achieve the accuracy? Your code for each part is expected to be less than 20 lines. The value of $\pi$, up to 100th decimal places, is given here

    \begin{align*}
        \pi =              3.1415926535 \quad 8979323846 \quad 2643383279 \quad 5028841971 \quad 6939937510 \\
            \phantom{\pi=3.} 5820974944 \quad 5923078164 \quad 0628620899 \quad 8628034825 \quad 3421170679
    \end{align*}
\end{homework}

\begin{fortran}[label={C:1-2}]{\href{https://github.com/iydon/CFDRust/blob/main/mae5005/code/1/bailey_borwein_plouffe_formula.f90}{bailey\_borwein\_plouffe\_formula.f90}}
program main
   use, intrinsic :: iso_fortran_env, only: f32=>real32, f64=>real64, f128=>real128
   implicit none
   CHARACTER(LEN=23) :: format = '(A13, I4, A7, f36.34)'
   integer :: n32, n64, n128
   real(f32) :: pi32, eps32 = 1.4012984643E-45_f32
   real(f64) :: pi64, eps64 = 4.9406564584124654E-324_f64
   real(f128) :: pi128, eps128 = 6.4751751194380251109244389582276465525E-4966_f128

   call calc_pi_f32(eps32, n32, pi32)
   write(*, format) '32-bit: n = ', n32, ', pi = ', pi32

   call calc_pi_f64(eps64, n64, pi64)
   write(*, format) '64-bit: n = ', n64, ', pi = ', pi64

   call calc_pi_f128(eps128, n128, pi128)
   write(*, format) '128-bit: n = ', n128, ', pi = ', pi128

   write(*, '(A)') '                   pi = 3.1415926535897932384626433832795029'
end program main

subroutine calc_pi_f32(eps, n, pi)
   use, intrinsic :: iso_fortran_env, only: f32=>real32

   real(f32), intent(in) :: eps
   integer, intent(out) :: n
   real(f32), intent(out) :: pi

   real(f32) :: delta, a, b

   n = 1 ; pi = 0.0 ; a = 1.0 ; b = 0.0
   do while (.true.)
      delta = (4.0/(b+1.0) - 2.0/(b+4.0) - 1.0/(b+5.0) - 1.0/(b+6.0)) / a
      if (abs(delta) <= eps) then
         exit
      end if
      n = n + 1 ; pi = pi + delta ; a = a * 16.0 ; b = b + 8.0
   end do
end subroutine calc_pi_f32

subroutine calc_pi_f64(eps, n, pi)
   use, intrinsic :: iso_fortran_env, only: f64=>real64

   real(f64), intent(in) :: eps
   integer, intent(out) :: n
   real(f64), intent(out) :: pi

   real(f64) :: delta, a, b

   n = 1 ; pi = 0.0 ; a = 1.0 ; b = 0.0
   do while (.true.)
      delta = (4.0/(b+1.0) - 2.0/(b+4.0) - 1.0/(b+5.0) - 1.0/(b+6.0)) / a
      if (abs(delta) <= eps) then
         exit
      end if
      n = n + 1 ; pi = pi + delta ; a = a * 16.0 ; b = b + 8.0
   end do
end subroutine calc_pi_f64

subroutine calc_pi_f128(eps, n, pi)
   use, intrinsic :: iso_fortran_env, only: f128=>real128

   real(f128), intent(in) :: eps
   integer, intent(out) :: n
   real(f128), intent(out) :: pi

   real(f128) :: delta, a, b

   n = 1 ; pi = 0.0 ; a = 1.0 ; b = 0.0
   do while (.true.)
      delta = (4.0/(b+1.0) - 2.0/(b+4.0) - 1.0/(b+5.0) - 1.0/(b+6.0)) / a
      if (abs(delta) <= eps) then
         exit
      end if
      n = n + 1 ; pi = pi + delta ; a = a * 16.0 ; b = b + 8.0
   end do
end subroutine calc_pi_f128
\end{fortran}

根据 Homework~\ref{H:1-2}，可以编写如 Code~\ref{C:1-2} 所示的代码。通过调研，\texttt{Fortran} 的子程序（\texttt{subroutine}）与函数均不支持泛型，且 \texttt{Fortran} 的流程控制语句无法写成一行的形式，而宏不支持生成多行内容。因此，放弃了降低可读性的奇技淫巧，采用朴素的方法分别实现作业要求中的单精度、双精度与四精度子程序。不同精度子程序实现\footnote{这句话读起来有些别扭，此处的“实现”为名词：implementation。}的差异只在类型别名上，而且子程序不忽略空格的话也只有 18 行，因此，应该可以看作满足作业中的行数要求。

易证，$\tfrac{4}{8k+1} - \tfrac{2}{8k+4} - \tfrac{1}{8k+5} - \tfrac{1}{8k+6}$ 与 $\tfrac{1}{16^k}$ 随着非负整数 $k$ 的增大而逐步趋近于零\footnote{$f(k+1)-f(k)<0$ 且 $f(k)>0$。}。因此，可以给定一个比较小的正数作为容忍度，通过顺序累加公式中的项数来逼近 $\pi$，当项的大小\footnote{编写代码时没有证明项数递减的结论，因此，仍然使用绝对值来比较大小，算是历史遗留问题。}小于给定的容忍度时，返回累加项数与 $\pi$ 的近似值。以上就是代码的思路，最后在主函数中对结果进行格式化输出即可。

主函数中针对不同的精度选用不同的容忍度，默认为该精度下的 smallest positive subnormal number，于是在主力平台上有如下运行结果：单精度累加项数为 33，有效小数位数为 6；双精度累加项数为 257，有效小数位数为 15；四精度累加项数为 4097，有效小数位数为 33。

与 Homework~\ref{H:1-1} 类似，不同版本的 \texttt{GFortran} 也出现了解析字面常量的差异问题，因此，不选用模糊的字面常量可以解决此问题。出现的两种输出如下，其中 \texttt{GFortran} 的版本如浅灰色文字所示，输出差异如深灰色标注区域所示。

\begin{plaintext}[minted options={numbers=left, gobble=0, escapeinside=||, python3}]
|\PYG{c}{GNU Fortran (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0}|
|\PYG{c}{GNU Fortran (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0}|
|\PYG{c}{GNU Fortran (GCC) 11.2.1 20220127 (Red Hat 11.2.1-9)}|
 32-bit: n =   33, pi = 3.1415925025939941406250000000000000
 64-bit: n =  257, pi = 3.1415926535897931159979634685441852
128-bit: n = 4097, pi = 3.141592653589793238|\colorbox{lightgray}{4626433832795024}|
                   pi = 3.1415926535897932384626433832795029
\end{plaintext}

\begin{plaintext}[minted options={numbers=left, gobble=0, escapeinside=||, python3}]
|\PYG{c}{GNU Fortran (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44)}|
 32-bit: n =   33, pi = 3.1415925025939941406250000000000000
 64-bit: n =  257, pi = 3.1415926535897931159979634685441852
128-bit: n = 4097, pi = 3.141592653589793238|\colorbox{lightgray}{2959685249090853}|
                   pi = 3.1415926535897932384626433832795029
\end{plaintext}
