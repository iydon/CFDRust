\section{\texttt{Fortran} 代码}\label{S:appendix-fortran}
\begin{fortran}[label={C:1-1}]{\href{https://github.com/iydon/CFDRust/blob/main/mae5005/code/1/input_and_output.f90}{input\_and\_output.f90}}
program main
   use, intrinsic :: iso_fortran_env, only: f64=>real32
   implicit none

   real(f64) :: number

   write(*, fmt='(A)', advance='no') 'Input  = '
   read(*, *) number
   write(*, fmt='(A, ES14.8, A, b32.32)') 'Output = ', number, ' = ', transfer(number, 0)
end program main
\end{fortran}

\begin{fortran}[label={C:1-2}]{\href{https://github.com/iydon/CFDRust/blob/main/mae5005/code/1/bailey_borwein_plouffe_formula.f90}{bailey\_borwein\_plouffe\_formula.f90}}
program main
   use, intrinsic :: iso_fortran_env, only: f32=>real32, f64=>real64, f128=>real128
   implicit none
   CHARACTER(LEN=23) :: format = '(A13, I4, A7, f36.34)'
   integer :: n32, n64, n128
   real(f32) :: pi32, eps32 = 1.4012984643E-45_f32
   real(f64) :: pi64, eps64 = 4.9406564584124654E-324_f64
   real(f128) :: pi128, eps128 = 6.4751751194380251109244389582276465525E-4966_f128

   call calc_pi_f32(eps32, n32, pi32)
   write(*, format) '32-bit: n = ', n32, ', pi = ', pi32

   call calc_pi_f64(eps64, n64, pi64)
   write(*, format) '64-bit: n = ', n64, ', pi = ', pi64

   call calc_pi_f128(eps128, n128, pi128)
   write(*, format) '128-bit: n = ', n128, ', pi = ', pi128

   write(*, '(A)') '                   pi = 3.1415926535897932384626433832795029'
end program main

subroutine calc_pi_f32(eps, n, pi)
   use, intrinsic :: iso_fortran_env, only: f32=>real32

   real(f32), intent(in) :: eps
   integer, intent(out) :: n
   real(f32), intent(out) :: pi

   real(f32) :: delta, a, b

   n = 1 ; pi = 0.0 ; a = 1.0 ; b = 0.0
   do while (.true.)
      delta = (4.0/(b+1.0) - 2.0/(b+4.0) - 1.0/(b+5.0) - 1.0/(b+6.0)) / a
      if (abs(delta) <= eps) then
         exit
      end if
      n = n + 1 ; pi = pi + delta ; a = a * 16.0 ; b = b + 8.0
   end do
end subroutine calc_pi_f32

subroutine calc_pi_f64(eps, n, pi)
   use, intrinsic :: iso_fortran_env, only: f64=>real64

   real(f64), intent(in) :: eps
   integer, intent(out) :: n
   real(f64), intent(out) :: pi

   real(f64) :: delta, a, b

   n = 1 ; pi = 0.0 ; a = 1.0 ; b = 0.0
   do while (.true.)
      delta = (4.0/(b+1.0) - 2.0/(b+4.0) - 1.0/(b+5.0) - 1.0/(b+6.0)) / a
      if (abs(delta) <= eps) then
         exit
      end if
      n = n + 1 ; pi = pi + delta ; a = a * 16.0 ; b = b + 8.0
   end do
end subroutine calc_pi_f64

subroutine calc_pi_f128(eps, n, pi)
   use, intrinsic :: iso_fortran_env, only: f128=>real128

   real(f128), intent(in) :: eps
   integer, intent(out) :: n
   real(f128), intent(out) :: pi

   real(f128) :: delta, a, b

   n = 1 ; pi = 0.0 ; a = 1.0 ; b = 0.0
   do while (.true.)
      delta = (4.0/(b+1.0) - 2.0/(b+4.0) - 1.0/(b+5.0) - 1.0/(b+6.0)) / a
      if (abs(delta) <= eps) then
         exit
      end if
      n = n + 1 ; pi = pi + delta ; a = a * 16.0 ; b = b + 8.0
   end do
end subroutine calc_pi_f128
\end{fortran}

\begin{fortran}[label={C:2-2-1}]{\href{https://github.com/iydon/CFDRust/blob/main/mae5005/code/2/unidirectional_flow.f90}{unidirectional\_flow.f90} (part 1)}
module solution
   use, intrinsic :: iso_fortran_env, only: f64=>real64
   implicit none

   public stepwise, numerical, analytical
contains
   subroutine stepwise(N, L, nu, u0, dt, u)
      integer, intent(in) :: N
      real(f64), intent(in) :: L, nu, u0, dt
      real(f64), dimension(N+1), intent(inout) :: u

      u(2: N) = u(2: N) + dt * ( &
         + 2.0*nu*u0/L**2 & ! u₀ = -L²/(2ρν) pₓ
         + nu/(2.0*L/N)**2 * (u(1: N-1)-2.0*u(2: N)+u(3: N+1)) &
      )
   end subroutine stepwise

   subroutine numerical(N, nt, L, nu, u0, dt, u)
      integer, intent(in) :: N, nt
      real(f64), intent(in) :: L, nu, u0, dt
      real(f64), dimension(N+1), intent(out) :: u

      integer :: ith

      u = 0.0 ! initial condition
      do ith = 1, nt
         call stepwise(N, L, nu, u0, dt, u)
      end do
   end subroutine numerical

   subroutine analytical(N, nt, L, nu, u0, dt, u, term)
      integer, intent(in) :: N, nt
      real(f64), intent(in) :: L, nu, u0, dt
      integer, intent(in) :: term ! when term<0, add until it stops increasing
      real(f64), dimension(N+1), intent(out) :: u

      real(f64), parameter :: PI = 4.0 * atan(1.0)
      integer :: ith, k
      real(f64) :: t, y, dy, C, old

      t = nt * dt; y = -L; dy = 2.0 * L / N
      do ith = 1, N+1
         u(ith) = 1.0 - y**2 / L**2
         if (term >= 0) then
            do k = 0, term-1
               C = PI * (k + 0.5)
               u(ith) = u(ith) - 4.0*(-1.0)**k/C**3 * exp(-C**2*nu*t/L**2) * cos(C*y/L)
            end do
         else
            k = 0
            do while (.true.)
               C = PI * (k + 0.5); old = u(ith)
               u(ith) = u(ith) - 4.0*(-1.0)**k/C**3 * exp(-C**2*nu*t/L**2) * cos(C*y/L)
               if (u(ith) == old) then; exit; end if
               k = k + 1
            end do
         end if
         u(ith) = u(ith) * u0; y = y + dy
      end do
   end subroutine analytical
end module solution
\end{fortran}

\begin{fortran}[label={C:2-2-2}]{\href{https://github.com/iydon/CFDRust/blob/main/mae5005/code/2/unidirectional_flow.f90}{unidirectional\_flow.f90} (part 2)}
program main
   use, intrinsic :: iso_fortran_env, only: f64=>real64
   use solution, only: stepwise, numerical, analytical
   implicit none

   ! user-specified variables
   integer :: N ! N = 8, 16, 32
   real(f64) :: nutL ! ν t / L² = 0.2, 1.0, 10.0
   ! known parameters
   real(f64), parameter :: L = 1.0, nu = 0.1
   real(f64), parameter :: u0 = 1.0 ! u₀ = -L² / (2 ρ ν) pₓ
   ! derived variables
   integer :: nt ! ν nt Δt / L² = nutL
   real(f64) :: dy ! Δy = 2 L / N
   real(f64) :: dt ! Δt = 0.32 Δy² / ν
   ! numerical and analytical solutions
   real(f64), allocatable :: un(:), ua(:)
   ! unimportant temporary variables
   integer :: ith, term = 100
   character(len=25) :: format = '(A, I4, A, f9.6, A, f8.6)'

   write(*, fmt='(A)', advance='no') 'N     = '; read(*, *) N
   write(*, fmt='(A)', advance='no') 'νt/L² = '; read(*, *) nutL
   dy = 2.0 * L / N
   dt = 0.32 * dy**2 / nu ! 1.28 * L**2 / N**2 / nu
   nt = int(nutL * L**2 / nu / dt) ! int(nutL / 1.28 * N**2)
   allocate(un(N+1), ua(N+1))
   open(1, file='numerical.dat', action='write')
   open(2, file='analytical.dat', action='write')

   ! plot and compare the velocity profiles from different grid resolutions
   call numerical(N, nt, L, nu, u0, dt, un)
   call analytical(N, nt, L, nu, u0, dt, ua, term)
   write(1, *) un
   write(2, *) ua
   ! find out at what dimensionless time, νt/L², the velocity at the center of the channel (y=0) reaches the value of 0.99u₀
   write(*, format) '[C] nt, νt/L², u(0, T)/u₀ = ', nt, ', ', nutL, ', ', un(int(N/2)+1)/u0
   ith = 0; un = 0.0
   do while (.true.)
      ith = ith + 1
      call stepwise(N, L, nu, u0, dt, un)
      if (un(int(N/2)+1) >= 0.99*u0) then
         write(*, format) '[N] nt, νt/L², u(0, T)/u₀ = ', ith, ', ', nu*ith*dt/L**2, ', ', un(int(N/2)+1)/u0
         exit
      end if
   end do
   ith = 0
   do while (.true.)
      ith = ith + 1
      call analytical(N, ith, L, nu, u0, dt, ua, term)
      if (ua(int(N/2)+1) >= 0.99*u0) then
         write(*, format) '[A] nt, νt/L², u(0, T)/u₀ = ', ith, ', ', nu*ith*dt/L**2, ', ', ua(int(N/2)+1)/u0
         exit
      end if
   end do

   close(1); close(2)
   deallocate(un, ua)
end program
\end{fortran}



\section{\texttt{Python} 代码}\label{S:appendix-python}

\python[label={C:python-unit_test}]{
    \href{https://github.com/iydon/CFDRust/blob/main/mae5005/test.py}{test.py}
}{
    ../test.py
}

\python[label={C:python-bits}]{
    \href{https://github.com/iydon/CFDRust/blob/main/mae5005/code/1/input_and_output.py}{input\_and\_output.py}
}{
    ../code/1/input_and_output.py
}

\python[label={C:python-unidirectional_flow}]{
    \href{https://github.com/iydon/CFDRust/blob/main/mae5005/code/2/unidirectional_flow.py}{unidirectional\_flow.py}
}{
    ../code/2/unidirectional_flow.py
}
